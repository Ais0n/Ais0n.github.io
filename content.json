{"pages":[],"posts":[{"title":"起点","text":"这是第一篇文章。 时隔大半年，终于给这个blog换上了新主题。（ICARUS, yyds！这个主题太合我胃口了w） 也许后面有空会DIY个2.0版本吧… 2020.12.19 ——————Split Line——————— 这里是黄彦玮的博客。浙大CS大三在读。 Welcome to Yanwei Huang’s blog. I’m a senior student from the department of Computer Science, ZJU.","link":"/2020/12/19/%E8%B5%B7%E7%82%B9/"},{"title":"计算机网络笔记","text":"《计算机网络》笔记整理 前面的章节在IPAD上，以后会补上 5.2.3 泛洪算法问题在于会产生大量数据包 抑制措施： 在每个数据包的头中设置一个跳计数器，初始值等于源到汇路径的长度，每跳一次就减1，减到0就丢弃这个包。 让路由器跟踪已经泛洪过的数据包，第一个路由器会在包上加一个序号，以后所有路由器为每个源路由器准备一张表，记录已经观察到的来自源路由器的序号。如果数据包在这张表中，就不能被泛洪到其他路由器。实际实现时，每个表使用一个计数器k作为参数，表示直到k的所有序号都已经观察到了。然后比较数据包的序号和k的大小即可。 特点：适用于广播，鲁棒性好（总能找到一条路径），但只有一个目的地时会很浪费 5.2.4 距离矢量路由算法（distance vector routing, 动态路由算法）应用——RIP 每个路由器维护一个以&lt;路由器，首选出境端口，估计距离&gt;为表项的表，然后按照固定的时间间隔给邻居发送一次这张表。 问题：收敛可能很慢；对好消息反应很快，对坏消息反应可能很慢–&gt;无穷计数问题 一个不完全的解决方案：将路径长度无穷大设置为最长的路径+1 5.2.5 链路状态路由（link state routing）应用——OSPF 过程： 发现它的邻居节点，并了解其网络地址。（在每一个点到点线路中发一个Hello数据包） 设置到每个邻居节点的距离或者成本度量值。（常用方法是成本与链路带宽成反比，或者采用延迟时间当做成本，计算方法为来回时间/2） 构造一个包含所有刚刚获知的链路信息包。（数据包的内容：标识符（谁发出去的）、序号（泛洪要用）、年龄、&lt;邻居-延迟&gt;） 将这个包发送给所有其他的路由器，并接收来自所有其他路由器的信息包。（泛洪） 计算出到每个其他路由器的最短路径。（每个路由器以自己为根算一个最小生成树） 收敛性好、适用于大网络。但是计算略复杂 几个问题： 为了减少拓扑结构复杂性，LAN会被一个虚拟的节点代替，此时需要指定一个和这个LAN相连的路由器来代表这个虚拟节点向其他节点发送链路信息。算延迟的时候只算一边，如下图，A到N还是算延迟的，N到A的延迟可以认为是0. age字段每秒钟减1，减到0就丢弃数据包 图5-13 发送和确认 书上p291举的例子要理解 5.2.6 分层路由书上图5-14 将路由器分成很多个子网络 同一个子网内的先跑一次算法，记录到节点的距离；然后连接不同子网的路由器之间再跑一次算法，一个节点到其他的子网不再记录到每一个节点的距离，只记录到子网的距离（数据包也只从同一个路由器走） 5.2.7 广播路由 Broadcast方法： 多目标路由（multi-destination routing），在数据包中加入多个目标地址 泛洪 逆向路径转发（当路由器收到一个包，它判断来的那个端口是不是数据包从发送者开始沿最佳路径转发过来的端口。如果是，则将这个包转发到除了来的那个端口以外的所有端口；如果不是，丢弃数据包。） 生成树（每个路由器需要知道它的哪些端口在生成树上，然后将数据包发送到来源端口以外的在生成树上的端口。前提是路由器需要知道生成树，所以适用于链路状态路由算法，不适用于距离矢量路由算法） 5.2.8 组播路由 Multicast最简单的方法是广播，但是会发到一些无关成员，造成浪费。 方法： 修剪树：图5-16，从根开始，从生成树上把不通往组成员的边删去。 缺点：路由器需要做大量的工作 具体的构造方法： 对于距离矢量算法，核心思想是逆向路径转发。如果一个路由器和这个组无关，需要发送一个PRUNE消息作为接受组播消息的相应，告诉邻居不要再给自己发送任何来自该组发送者的消息。——例子：距离矢量组播路由协议DVMRP（Distance vector multicast routing protocol） 对于链路状态路由算法，每个路由器知道生成树、拓扑结构、哪些主机输入哪个组，直接构造一棵sink tree，然后删除不连到组成员的链路即可。——例子：组播MOSPF（Multicast OSPF） 核心树（core-based trees），计算某个组的单棵生成树 采用这种方法时，所有路由器同意以某个路由器为根（称为核心core或者会聚点rendezvous point），然后每个成员给根发送一个数据包来构建树。 优点是每个路由器只要为每个组保存一棵树，省资源。例子——协议独立组播PIM（Protocol Independent Multicast） 5.2.9 选播路由 Anycast所有被选到的成员将被赋予同一个组地址，然后路由器像往常一样工作，选择最短路径，所以数据包会被发送到距离路由器最近的一个组内节点。 5.2.10 移动主机路由 Mobile Host图5-19 重要 4步：1.注册转交地址 2.发送者往家乡地址发送数据包 3. 隧道(tunneling)到转交地址（需要用一个新的头包裹，即封装该数据包，encapsulation） 4. 应答发送者 5. 发送者通过隧道将随后的数据包发给转交地址 5.2.11 自组织网络路由Ad hoc图5-20（有点复杂） 5.3 拥塞控制算法（听说不考） 供给（provisioning），购买带宽或者网络资源 流量感知的路由（traffic-aware routing），把流量拆分到多个路径 只考虑负载时会带来不稳定的路由和许多潜在问题 准入控制（admission control）降低负载 漏桶：描述突发流量的描述符 ——5.4节讨论 一种方案：选择一条没有拥塞路由器的传输路径（和路由算法结合） 流量调节 两个问题： 如何确定快要发生拥塞？估计延迟时间，将上一次的延迟和当前瞬时队列长度的采样值进行加权平均，来估算排队延迟。 如何反馈信息给发送方？发送抑制包（choke packet）。方法是标记包头部的某一个bit。 Internet中的方案：显示拥塞通知（ECN，Explicit congestion notification）图5-25，当发送数据包时，如果经过了某个拥塞的路由器，就标记这个数据包，接受方看到标记以后可以在应答包当中顺便告知发送方拥塞的信息。 另一个方案：逐跳后压，书P309图5-26(b) 负载脱落（load shedding） 丢弃数据包：wine（旧的包比新的包重要，丢弃新的包）和milk（新的包比旧的包重要，丢弃旧的包） 随机早期检测算法（RED，Random early detection）当某条链路上的平均队列长度超过某个阈值时，随机丢弃一小部分数据包——在能使用ECN时优先用ECN 5.4 服务质量（听说不考）5.4.1 背景服务质量（QoS）=带宽+延迟+抖动（延迟的方差）+丢失 P312图5-27 重要 5.4.2 流量整形traffic shaping客户向服务端描述可能的流量形式，这个约定有时又叫做服务等级约定（SLA，service level agreement）同时服务器要对一个流进行检测，丢弃超出约定模式之外的数据包，这个过程叫做流量监管（traffic policing） 漏桶和令牌桶： 漏桶算法leaky bucket algorithm 漏桶算法思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会直接溢出，可以看出漏桶算法能强行限制数据的传输速率。 令牌桶算法token bucket algorithm 令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。 见书P314倒数两段 P316有一个计算要掌握 5.4.3 数据包调度算法： FIFO 缺点是队列满了以后新来的包会被丢弃（尾丢包tail drop），有造成饿死的可能 公平队列算法（fair queueing）和加权公平队列算法（WFQ）书P318-319看书，理解掌握 5.4.4 ~ 5.4.6 Skipped5.5 网络互联5.5.1 要连接的网络可能有很多不同，见P327图5-385.5.2路由器和交换机（网桥）的区别：路由器每次提取一个包的ip地址，然后根据不同网络采用不同的协议对数据进行封装。交换机（或网桥）上，整个帧是根据其MAC 地址传送的。交换机不必了解正在被交换的数据包所采用的网络层协议，同样路由器也不必了解交换机所采用的链路层协议。 5.5.3 隧道Tunneling英吉利海峡那个例子，把原来的协议的数据包用隧道协议的包头封装 5.5.4两级路由算法。在每个网络中，使用一个域内（ intradomain ）或者内部网关协议（ interior gateway protocol ）进行路由（“网关”是“路由器”的旧称）。为了让数据包跨越构成互联网的网络，就需要用到域间（ interdomain ）或外部网关协议（ exterior gateway protocol ）。网络可能全部使用不同的域内协议，但它们必须使用相同的域间协议。在Internet 上，域间路由协议称为边界网关协议（BGP, Border Gaterway Protocol ） 还有一个更重要的术语要介绍。由于每个网络独立于所有其他网络运营，因此这样的网络通常称为一个自治系统（ AS, Autonomous Sysem ）。AS 的良好默认模型是ISP 网络。事实上，一个ISP 网络或许由多个AS 组成，如果它管理或收购了多个网络。 5.5.5 分段分段=拆+不拆，其中拆=透明+不透明，图5-42，注意不透明的时候包的重组是在目标主机完成的 路径MTU发现：图5-44 每个IP数据包发出时在它的头设置一个比特，指示不允许对该数据包实施分段操作。如果一个路由器接收的数据包太大，它就生成一个报错数据包并发送给源端，然后丢弃该数据包。 5.6一、 IPv4IP包的基本单位是字节，但是IP包头的基本单位是字 固定部分5个字+可选部分（0~10个字） IP地址 32bit 点分十进制表示法 子网掩码 子网划分 Version字段 0100 IHL字段 头的长度 最小值为5 因为只有4位 所以包头最大是15个字，即60字节，所以Options字段最多40字节 Differentiated Services 最开始叫Type of Service，6bit，但是后来弃用了，现在是8bit，前6 位用来标记数据包的服务类别，我们在本章前面描述过的加速服务和确保服务：后2位用来携带显式拥塞通知信息，比如数据包是否经历了拥塞，我们在本章的拥塞控制部分描述了显式拥塞通知。 Total Length 数据包（头+数据）总长度，16bit，说明数据包最多65535字节（常考） Identification 和源地址、目标地址一起，三者唯一确定一个数据包 Time to live 原来是这个包在网络上存在的时间，以秒为单位。现在是跳计数器，当它递减到0 时，数据包就被丢弃，并且路由器给数据包的源主机发回一个报警包。 Protocol 后面的数据的协议 Header Checksum 包头部的校验和 算法：当数据到达时，所有的16位（半宇）累加起来，然后再取结果的补码。该算法的目的是到达数据包的头校验和计算结果应该为0。 DF=don’t fragment 置1表示不允许分段 MF=more fragments 置1表示不是最后一个段 Fragment offset 指明了该段在当前数据报中的位置。除了数据报的最后一个段以外，其他所有段的长度必须是8字节的倍数。由于该字段有13位，所以每个数据报最多有8192个段 从概念上讲， CIDR 的工作原理如下所述。当一个数据包到达时，路由器扫描路由表以便确定目的地是否在前缀的地址块内。有可能多个具有不同前缀的表项得到匹配，在这种情况下，使用具有最长前缀的表项。因此，如果有一个匹配/20掩码的表项，同时还有一个匹配/24掩码的表项，则使用/24表项来查询数据包的出境线路。——最长前缀匹配策略 分类寻址 图5-53 5种类型 特殊寻址 图5-54 考试——例：C类地址最多有多少个主机：2^8 -2=254（去掉全0全1） A类地址开头的Network是1-127 不是0-127 B类和C类 network可以填0 NAT 1.出境时做地址的映射，同时进程将自己绑定到一个“源端口“上 2.入境时，需要维护一个&lt;IP+端口&gt;→&lt;路由器端口&gt;的表 二、IPv6还是32bit的整数倍 区分服务字段：和IPv4相同，8bit Flow label：流的标识符 用于服务品质 有效载荷长度（Payload Iength）宇段指明了紧跟在图5-56 中40 个字节头之后还有多少字节数。和IPv4不同，40 字节的头不再像以前那样算作长度中的一部分。 Next header字段 表明当前头之后还有哪些头 最后一个头的该字段表示该数据包将被传递给哪一个传输协议处理 跳数限制Hop limit相当于IPv4里的TTL IP地址：16个字节 冒号十六进制记法 扩展头——逐跳头hop-by-hop header 书p355 图5-58 要熟悉 三、IP控制协议ICMP——Internet控制消息协议 P358图5-60 底层是IP协议来承载 ARP——地址解析协议 核心是要获取目标的以太网地址 P360图5-61 一台机器用了ARP之后可以将结果缓存起来。ARP缓存项应当有一个过期时限。 一台机器重新配置IP之后应当发送一个ARP请求广播自己的IP地址，会在其他主机的ARP缓存中加入一个表项。这个请求成为免费ARP（gratuitous ARP）。如果发送这个ARP包的主机意外收到了一个应答，说明两台机器被分配了相同的IP地址。 默认网关：一台主机想要给网络外的主机发送信息时，查找的默认的路由器 ARP代理：路由器代替网络外的主机回复ARP请求报文（P361有个例子） DHCP——动态主机配置协议 每个网络需要有一个DHCP服务器负责地址配置。主机启动的时候会广播一个报文请求IP地址，这个包叫做DHCP DISCOVER包。DHCP服务器收到以后分配一个IP地址，发送DHCP OFFER包返回。 一般采用租赁（leasing）技术，分配的IP地址要定期renew MPLS——多协议标签交换 首先回忆标签交换：根据一个标签label进行发送路径的判断，本质是交换而不是转发，见图5-3 MPLS中，主机和进入MPLS网络的第一个路由器（称为标签边缘路由器，LER，Lable Edge Router）之间采用无连接的IP协议，在MPLS网络内部采用面向连接的技术。MPLS中的路由器被叫做标签交换路由器（LSR，Label Switched Router）。完整过程见P364 图5-63 MPLS是一个2.5层的协议。标签会放在一个帧的头部，帧格式见图5-62，4bit，标签20bit，存放了索引。 对路由器来说，更常见的做法是将终止在某个特定路由器或者LAN 的多个流合并成一组，并为这些流使用同一个标签。这些被合起来共享同一个标签的流称为属于同一个转发等价类（FEC, Forwarding Equivalence Class） 实际应用中一个包可能有多个标签，称为标签栈。图5-62中的S bit为1时表示这个标签是最底部的标签，下面没有其他标签了。QoS表示服务的类别。TTL字段指出该数据包还能被转发多少次，每经过一个路由器被递减1 。如果降为0，则该数据包将被丢弃。 RIP——Routing Information Protocol 距离向量算法 收敛性不好 只能用于小网络 两个路由器之间的距离默认为1 内部路由协议IGP 用UDP承载 RIP 1版本仅支持分类的IP地址，不支持无级的IP地址，RIP2都支持 OSPF——内部网关路由协议 链路状态算法 骨干网 内部路由协议IGP 用IP承载 区域边界路由器（ABR）、骨干路由器、AS边界路由器（ASBR）、内部路由器的理解 P367图5-65 外部成本指从AS 边界路由器通往目的地的外部路径的成本。 部分细节 skipped BGP——外部网关路由协议 距离向量算法（变种）但是不仅互相传输到目的地的距离，还传输到目的地的路径 所以改善了收敛性 外部路由协议EGP 用TCP承载 6 运输层6.1.2 TCP状态机 要考填空6.1.3 原语：和socket实验编程结合 6.2 传输协议的要素点对点和端对端的区别： 数据链路层 点对点 包接受的顺序和发送的顺序一样 没有存储能力 不必指定它要与哪一台路由器进行通话一一每条出境线路直接通向一台特定的路由器 建立连接的过程非常简单 运输层 端对端 要解决顺序问题 且路由器有存储能力 要解决包隐藏的问题 必须显式地指定接收方的地址 建立连接的过程非常复杂 带宽波动比数据链路层更加显著，需要新的解决方案 6.2.1 寻址传输服务访问点（TSAP, Transport Service AccessPoint） 实例：端口 网络服务访问点（NSAP. Network Service Access Point ） 实例：IP地址 使用TSAP和NSAP进行连接的图，把TSAP想象成端口，NSAP想象成IP地址就行 问题：Host1怎么知道Host2上的进程跑在哪个端口？需要一个特殊进程——端口映射进程（portmapper） 如何唯一标识一个连接：通过两个端点在空间上标识一个连接；通过序号（可循环使用）区分时间上前后的连接，这个序号选一个最近合理的时间范围内没有使用过的即可 初始连接协议（ initial connection protocol ）：不是每个想象的服务器都在一个知名TSAP上监听，每台希望向远程用户提供服务的机器有一个特殊的进程服务器（ process server ）充当那些不那么频繁使用的服务器的代理。这个服务器在同一时间监昕一组端口，等待连接请求的到来。一个服务的潜在用户发出一个连接请求，并指定他们所需服务的TSAP地址。如果该TSAP地址上没有服务器正等着，则他们得到一条与进程服务器的连接。 6.2.2 连接建立：三次握手=连接请求+连接请求确认+连接请求确认的确认6.2.3 连接释放：对称释放（”文明“的释放，两个方向看作两个单独的连接）和非对称释放（“野蛮”的释放，一方挂断就断开连接）核心思想：传输层用户必须参与进来决定何时断开连接，虽然这个问题传输实体本身无法彻底地解决 6.2.4 差错控制 流量控制 与数据链路层一致一个特别的问题：关于滑动窗口协议，传输协议通常使用较大的滑动窗口，因此它可能需要一个相当数量的缓冲区用作滑动窗口。发送端和接收端两端都需要缓冲区。缓存区的大小分配是一个问题，所以需要采用动态缓冲区分配算法，书上P406图6-16 6.2.5 多路复用多路复用——允许一个网络层连接（即IP地址）上建立多个传输层连接 逆向多路复用——如果一个用户有多条网络路径可用，可以将一个连接上的流量通过轮询的方式摊到其他连接 6.2.6 崩溃恢复 书上那张图看不懂 skipped6.3 拥塞控制 听说不考 skipped6.4 UDP 用户数据报协议6.4.1 UDP 无连接 实时性好 可靠性不好 包的格式：整数个字节 由头部+payload组成 头部以字为单位（4字节的整数倍） （不一定基于IP协议） 加了源端口（16bit）和目标端口（16bit） 从而支持多个任务 因为端口16bit 所以一共0-65535 共65536个端口 UDP长度字段：包含8字节的头部和数据的总长度，最小长度是8字节（即只有一个头部），最大长度是65515字节（65535-20，20是IP包的头部长度） 拿IP协议的假头一起来算checksum 算法见https://seanwangjs.github.io/2017/10/19/udp-protocol-checksum.html 6.4.2 RPC（Remote Procedure Call）远程过程调用图6-29 给出了执行RPC 的实际步骤。第1步是客户调用客户存根。这是一个本地过程调用，其参数按照常规的方式压入到栈中。在第2步，客户存根将参数封装到一个消息中，然后通过系统调用发送该消息。封装参数的过程称为列集（ marshalling ）。在第3步，操作系统将消息从客户机器发送到服务器机器上。在第4步，操作系统将入境数据包传递给服务器存根。最后，在第5步中，服务器存根利用散集（unmarshelled）得到的参数调用服务器过程。调用的结果沿着相反的方向按同样的路径传递。 RTP（Real-time Transport Protocol）实时传输协议 要支持多个流 保证流之间的顺序 并保证流之间的同步 由头部+payload组成 头部以字为单位（4字节的整数倍） 时间戳：用于同步 CC表示有多少个流被合并了 然后通过identifier分离 RTP的伴随协议RTCP 两者都是用UDP承载的 RTCP表示当前网络承载的情况 6.5 TCP面向连接 实时性不好 可靠性好 面向字节流","link":"/2020/12/21/computer-network/"},{"title":"字节前端实习面经","text":"2020/12/24 Interview by Bytedance Date: 2020-12-24 10:15 Place: Online Notes: 机试考得不难，轻松满分，有一道题是让你实现一个LRU算法 上来是自我介绍，大概谈了背景、项目经历、对前端感兴趣的point，简单展望了一下未来，2min，感觉发挥得挺好的 因为我之前提到我初中开始有接触前端，所以简单问了一下那时的情况 然后问了一下项目经历，问了我收获最大的地方是什么，我答的是技术栈的提升和团队合作能力的提升，这个也是之前准备过的，比较顺利 同时它还追问了我技术栈里收获最大的point，我答的是React.js和Canvas，凭感觉答的还行 然后它又让我简单描述了一下做项目过程中遇到的问题，是怎么解决的，我回答的是react里useEffect多次修改hook只会渲染一次的问题 之后问了我的网站项目，这里提到了如何最小化网站的宕机时间，这个我没答上来，我当时口胡了一个热重载调试，但是估计正确答案不是这个 然后问了我有没有用过docker，让我简单说明一下作用。今年OS实验的时候刚好用了docker+qemu搭操作系统，所以我说用过，但是我回答的时候不小心答成了qemu的作用，说它支持不同的体系结构。好在docker的作用我也有说对的一部分，我提到了面向对象新建容器的优越性。 问了我有没有去了解过现在前端一些前沿的东西/主流框架新特性，这里说实话平时也没太注意，我回答的是React的ES6的一些新特性，勉强答得还行 然后问我有没有去看过一些前端框架的源码，很直截了当地答了没有qwq 又问我除了简历上的项目以外有没有写过一些自己的小工具/小项目，很直截了当地答了没有qwq*2 之后问了一下我对他们团队的了解，对他们产品的使用体验 最后是我提问面试官的环节，主要问了人员状况以及未来发展的一些问题 Summary: 多做项目真的很重要，这次手握两个项目，面试官的问题就主要围绕这两个项目展开。另一个好处是多做项目了以后回答很多问题就算不准备也会很有底气。 要多关注行业前沿的东西。 再来就是平时要多coding，努力提升技术栈。 Update: ​ 12月25号收到offer~算是意料之中。感觉面试的时候面试官就没怎么刁难我，应该还是稳的hhh ​ 2021.1.5","link":"/2021/01/05/bd-notes/"},{"title":"大三上学期总结","text":"一些简单的碎碎念 前言今天是寒假的第一天，来写一写关于大三上学期的回忆吧qwq 这个学期总体还是挺累的，但是从结果上来看可能是最不错的一个学期了 我觉得可写的东西还是挺多的？那就直接开始—— 基本情况这学期总共只选了19.5学分（含小学期），分别是Linux小学期，OS，计网，体系结构，计算理论，还有一门思政课习概。 本来还选了一些别的课，但是后来陆续都退掉了，主要原因是因为选到了OS的教改班，实验任务很重，综合考虑了以后还是退掉保绩点，至少目前来看这一决定还是正确的。 Linux小学期jjm的Linux小学期，我觉得大二最推荐的小学期就是这个，选了这个能减轻OS不少的负担，OS的期末考试也会考察很多Linux的基本指令。这课的讲课是一言难尽的，建议自学，就看Neil Matthew和Richard Stones的《Linux程序设计》就够了。刚开课那几天建议快速自学完Shell程序设计的部分，因为课程最后有个小考试。建议至少留出10-15天的时间给这门课的实验，因为任务量还是比较大的。 最后得分：96/5.0 OS概况OS选到的是Yajin Zhou老师的班。这门课今年安排了9+n个助教（n是因为后来发现9个助教不够，又新添加进去的），一共有8个难度递增的Lab。从绩点的角度来说，我的观点和查老师上的一样：如果未来还是有未教改的平行班，我可能还是推荐选平行班，但是如果全面教改，选zyj老师不会亏的。 上课考纲内课程内容本身的学习我觉得还是不难的。周老师作为领域中的大牛，经常会给我们拓展一些安全领域或者是工业界上的例子，认真听还是很有收获的，可惜我到后半学期就没有仔细听拓展的内容了。 课本的话，OSC那本书的中文版我觉得写的是相当不错的。OSTEP则以风格有趣、通俗易懂而著称，这本书是我看过的书里面最喜欢的专业类书籍了，犹记得我开学第一周啥也没干，就只把这本书通读了一遍，这本书的风格就像读小说一样令人上瘾，强烈推荐。 OSTEP英文版：http://pages.cs.wisc.edu/~remzi/OSTEP/ OSTEP中文版：http://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/ 另外是这门课作业部分，说实话这一部分我不是很满意，一方面因为周老师的作业题里面总会夹杂几道光靠课程知识无法解决的怪题，或是重复无意义的计算的水题。我倒是期末复习的时候在课后题里面找到了一些还不错的题，总之希望老师可以重新设计一下这门课的作业。另外一个部分是作业的给分，虽然最后事实证明作业得分对总评影响不大，但是每次作业扣个十几分还不写评语真是非常搞人心态。 作业中的实验zyj的OS课还有一个特色是作业里包含实验，不过这些实验的难度和任务量都低于常规的实验部分。这学期一共有两个小实验，第一个是写一个内核模块，遍历PCB和TCB，输出进程和线程信息；另一个是模拟虚拟地址到物理地址的翻译。 第一个实验中，第一个难点在于内核模块的编写，这个网上相关的blog很多，学一下应该不难。但是要注意，如果在虚拟机下做这个实验，一定要记得做之前拍一个快照，不然万一程序有错误可能造成内核崩溃，再恢复会很麻烦。第二个难点在于Linux中内置的list_head链表结构以及与之相配套的宏，最关键的一个宏是list_entry（等价于container_of），它的作用是根据一个list_head元素的指针得到包含该元素的对象的指针，通过将地址减去偏移量实现，这是因为对象内元素的offset是不会改变的。这个设计我觉得可以说是非常精妙，还是非常有必要了解一下的。 （本部分可以参考的资料：linux链表说明 linux内核模块说明 《深入理解Linux内核》） 第二个实验是地址转化，我做的非常痛苦，究其原因是因为老师没有给出详细的资料。（因为老师给的pdf是32位的，但是实验是64位的，后来听室友说好像源网站上是有64位的，不过我做的时候没找到）一些细节我觉得还是应该提一下，比如： CR3寄存器中储存了Page Map Level 4 Table (PML4)的值。但是，这一寄存器并不能通过mov指令或者Linux源码中的__read_cr3()获得，原因是CR3寄存器在进程切换时会被修改，如果在内核模块中直接读取，读到的是内核进程的PGD的地址。解决方法是，由于Linux操作系统在进程调度时会将cr3寄存器的值存入进程的mm结构体（类型为mm_struct）中的成员pgd。所以，我们必须通过访问用户进程的mm结构体中的pgd成员来获得cr3寄存器的值。 获得段选择子。段选择子需要根据变量的性质来决定。这里tmp是一个临时变量，储存于栈中，应当用选取ss段寄存器。但是，我们注意到Linux在运行一个用户进程时会将ss寄存器设为用户态ds的值。以下是Linux源码中的对应部分（代码版本：5.4.48） 1234567891011121314151617181920212223242526272829303132333435/* /arch/x86/kernel/processor_64.c, lines 449 ~ 480*/static voidstart_thread_common(struct pt_regs *regs, unsigned long new_ip, unsigned long new_sp, unsigned int _cs, unsigned int _ss, unsigned int _ds){ WARN_ON_ONCE(regs != current_pt_regs()); if (static_cpu_has(X86_BUG_NULL_SEG)) { /* Loading zero below won't clear the base. */ loadsegment(fs, __USER_DS); load_gs_index(__USER_DS); } loadsegment(fs, 0); loadsegment(es, _ds); loadsegment(ds, _ds); load_gs_index(0); regs-&gt;ip = new_ip; regs-&gt;sp = new_sp; regs-&gt;cs = _cs; regs-&gt;ss = _ss; regs-&gt;flags = X86_EFLAGS_IF; force_iret();}voidstart_thread(struct pt_regs *regs, unsigned long new_ip, unsigned long new_sp){ start_thread_common(regs, new_ip, new_sp, __USER_CS, __USER_DS, 0);} 可以看到，regs-&gt;ss=_ss表明ss寄存器的值被设为了_ss，而从start_thread中传递的参数可以看出_ss对应的值为__USER_DS，即用户态ds的值。 所以我们直接获取段寄存器ds的值作为段选择子。 本实验可以参考的资料： Linux 5.4.0 源代码 https://cloud.tencent.com/developer/article/1421792 Intel 64bit IA-32 架构 官方Manual Vol.3 Chapter.4 https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-system-programming-manual-325384.html https://www.konoui.dev/post/2017-05-26-010-new/ https://carteryagemann.com/pid-to-cr3.html https://jasoncc.github.io/kernel/jasonc-mm-x86.html 实验单从实验部分来讲，这门课是我觉得大学到现在上过的最世一大的课程，没有之一，当然难度也是非常的大。这门课的实验部分在设计上主要仿照了清华大学的OS实验，但是清华好像是用的ARM架构或者X86架构，我们的是基于Riscv全部重新设计的一遍。由于我们是第一届，做的时候完全没有任何前人的资料可以参考，加上实验手册很多地方都不完善，而且之前计组也没有学过riscv汇编，做起来异常痛苦，我平均每个实验都花了三天以上的时间。希望老师能够结合我们这一届同学的经验，对未来的实验手册加以改进。 我做完了Lab0-Lab6，本来是想写一个详细的实验补充说明，但是鉴于昨天看到了一个帖子，上面已经总结的非常完善了，故此处略过。 这里再多说一句关于Lab6，这里贴一下当时我在报告中提的建议： 在做这个实验的过程中，我觉得实验指导还有如下可以优化的地方： get_unmapped_area的实现中，采用从0地址遍历的简单方法，建议明确说清楚是通过页表来判断虚拟地址是否被映射的。因为如果不借助页表，只有一个虚拟地址，是没有办法知道这个虚拟地址有没有被映射的。另外，这里的设计本身值得商榷，因为这一算法忽略了一种特殊情况，那就是某一个地址被映射了，但还没有给它分配物理页的情况，这时访问页表会发现映射不存在，但实际上虚拟地址已经使用mmap映射过了。建议可以在实验报告中说清楚。 实验中很多函数其实不会被真正调用到，比如上面提到的get_unmapped_area，这里可以理解是实验设计者想要做一些简化，但也建议可以在实验手册中说明清楚。 建议优化本实验的输出格式。 非常推荐在讲解slub和buddy system原理的时候，加入我推荐的那篇博客的链接，和本实验指导中的链接形成了互补的作用。我觉得这篇博客的讲解真的非常出色，对我理解这个实验的原理起到了极大的帮助。 考试今年考试考的非常简单，所以大家成绩都不错。但其实，这门课也是可以考的很难的。我个人是考前刷完了一整本的王道考研题，感觉这本书对知识点的讲解在思路上还是非常清晰的，另外每一节的习题都推荐做做。最后题目的构成中，选择题大约有40%来自于王道上的题，另外有10%来自于jjm班作业题，还有两三道来源于一份叫做“某年原题”的pdf。 给分&amp;吐槽zyj这学期开始把规则制定的极其严格，每个实验只能提交一次、按测试点给分、测试点部分占80%，以至于当时我甚至有挂科的预感。结果学期过程中不断设置各种bonus，调低测试点比例和难度，到了期末考试前，更是将前六个实验和bonus实验的比例进一步调大，调分力度感天动地，拯救数万CS学子于水火之中（笑），虽然对我这种提前做了Lab6的很不公平就是了。不过最后给分还是相当厚道，我觉得对得起我这一学期的努力，看到成绩的时候真的是感慨万分。 最后得分：96/5.0 体系体系课选到的Kai Bu的班。不说了，我爱Kg一辈子，这里我只有一句话想说：选到kg的课，真的求大家好好上吧，不要辜负kg对大家的期待，kg这么温柔且善良的人值得被温柔以待。 实验部分几乎是没有难度的，当然如果以后改成Riscv那就不好说。 Kg的作业质量非常高，最后期末有相当一部分的题来自于kg的两次作业。 印象中能搜到的历年卷大概是1999-2005大题、2002、2003-2004，还有一个未知年份.pdf，这几份做做还是挺好的。还有一份wk的2013样卷必做，今年很多题来自于那上面。 最后推一下我自己发在98上的回忆卷https://www.cc98.org/topic/5026696 这门课真是太开心了，kg人又好，压力也不大，还结识了一堆好朋友，最后给分又好，我tm吹爆，选到这门课真是八辈子的福气 最后得分：95/5.0 习概现在回想习概真是渡劫…也不知道该说是运气好还是运气不好，选到了一个一半人都在摸鱼的小组，最后组长带领着几个人把几乎所有的活都做了，然后也顺理成章的平时分拿满了。最后期末全年级卷面都很低（平均60左右），不过我感觉我可能是被老师捞过了，最后成绩还挺满意。（吹爆wxm老师！） 这门课考试是开卷，但是听说以后会加大力度，不知道会不会就直接闭卷了…开卷我带的资料是PPT的打印版、一本黄色封面的习概学习纲要（小册子）、还有中/特理论和实践研究（蓝封面，应该是研究生的课本）。有条件的同学可以考虑带肖四。 最后得分：89/4.5 计网概况计网这课，上过的都知道，已经不是离谱二字能形容了。计院这么多专业课，每门课都是一本一千多页的鬼书，但是像计网这样知识点极多极碎，对细节要求极高的课程，我觉得找不出第二门了。反正，既然选了这门课，就要做好苦战的准备。 上课我选到的是hzq老师的班。不得不说，计网这课光靠上课完全没有办法把一千多页的课本将清楚，主要还是靠自学。但是，hzq老师毕竟是经验丰富的老师，虽然总感觉他每一章都是讲得不甚清楚，但我听到后来越来越佩服hzq老师的讲课功力——其实这才是计网这课的正确讲课姿势。计网这课的老师就应该梳理清楚每一章中间的框架结构，说清楚协议与协议之间的联系，具体的细节在有限的时间内确实不应过多涉及。 这门课我建议一定要记笔记，课后要抓紧时间对上课讲的东西，对照课本全部过一遍，不然拖到期末真的很要命。 实验hzq老师班的实验ddl都在期末，这就导致平时感觉没有什么压力，然后大家也就顺理成章地把实验都拖到了后半学期做，然后…冬学期整个人就快没了。所以我的建议是，实验1,7,8一开学就可以做了，需要到实验室去做的实验2,3尽早做，实验4,5,6尽量安排一个整天的时间一口气做完。 考试计网这课的考试，是最适合题海战术的，或者说刷题就是应对这门课考试的最好方法。我考前刷完了王道一整本、95页的试卷整理、18-19试卷、zqf班作业、lkj班作业、hzq班quiz，基本上最后考试80%以上的题都是做过的。当然这其实是非常花费时间的应试方法，不过很有效，建议考前留出充分的时间准备这门课（像我是考前一个月左右就开始准备了），千万不要到考前两三天突击。事实证明，将课本过一遍的复习方法在大多数情况下没有直接做题来的有效。 计算理论不得不说，今年jxg讲计算理论彻底刷新了我之前上他离散数学课留下的印象，废话已经比之前少很多了，另外对于书本的内容讲解的非常透彻，节奏也刚刚好，再加上这么课本身是jxg负责的，选了绝对不亏。两次quiz不提前公布时间，难度还是有的，这学期分别是安排在秋学期第八周和冬学期第三周，内容分别是第二章和第三章。 关于考试，期末考试的题型是固定的，所以这门课也非常适合刷题应对，考前两天过完ppt就可以直接开始做题了，最后判断题有一半是近年原题。如果有条件的话可以去问自己的研究生学长要当年的研究生计算理论试卷，听说有很多是重复的。 隔壁毛老师讲课水平也很好，而且总结了一份非常详细的notes，听说平时分也基本都给满了，很值得一选。我建议jxg班的同学如果时间允许可以问毛老师的同学要来他们班的notes看一看，上面有很多jxg上课没有提到但是判断题里常考的结论。 —————————————– 分割线 —————————————– 总的来说这学期为了课业牺牲了很多，比如没有挤出什么时间做科研了……虽然这学期看上去不错，但是作为一个大二排名后50%的菜菜，想要刷高绩点必然是一条很艰难的路……希望后面几个学期还能顺顺利利吧……","link":"/2021/01/29/g3-1-summary/"},{"title":"2021&#x2F;01&#x2F;30 更新日志","text":"2021/01/30 对网站进行了较大的优化 本次优化内容如下： 添加了评论功能，采用gitalk组件 添加了文章目录功能 添加了访问统计功能 优化了归档 清除了关于cookies的提示 添加了分享功能 To-do-list： 考虑加一个看板娘 考虑修改背景图 夜间模式","link":"/2021/01/30/upd-210130/"}],"tags":[{"name":"其它","slug":"其它","link":"/tags/%E5%85%B6%E5%AE%83/"},{"name":"面经","slug":"面经","link":"/tags/%E9%9D%A2%E7%BB%8F/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"}],"categories":[]}