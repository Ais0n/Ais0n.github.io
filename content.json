{"pages":[],"posts":[{"title":"起点","text":"这是第一篇文章。 时隔大半年，终于给这个blog换上了新主题。（ICARUS, yyds！这个主题太合我胃口了w） 也许后面有空会DIY个2.0版本吧… 2020.12.19 ——————Split Line——————— 这里是黄彦玮的博客。浙大CS大三在读。 Welcome to Yanwei Huang’s blog. I’m a senior student from the department of Computer Science, ZJU.","link":"/2020/12/19/%E8%B5%B7%E7%82%B9/"},{"title":"计算机网络笔记（维护中）","text":"《计算机网络》笔记整理 前面的章节在IPAD上，以后会补上 5.2.3 泛洪算法 问题在于会产生大量数据包 抑制措施： 在每个数据包的头中设置一个跳计数器，初始值等于源到汇路径的长度，每跳一次就减1，减到0就丢弃这个包。 让路由器跟踪已经泛洪过的数据包，第一个路由器会在包上加一个序号，以后所有路由器为每个源路由器准备一张表，记录已经观察到的来自源路由器的序号。如果数据包在这张表中，就不能被泛洪到其他路由器。实际实现时，每个表使用一个计数器k作为参数，表示直到k的所有序号都已经观察到了。然后比较数据包的序号和k的大小即可。 特点：适用于广播，鲁棒性好（总能找到一条路径），但只有一个目的地时会很浪费 5.2.4 距离矢量路由算法（distance vector routing, 动态路由算法）应用——RIP 每个路由器维护一个以&lt;路由器，首选出境端口，估计距离&gt;为表项的表，然后按照固定的时间间隔给邻居发送一次这张表。 问题：收敛可能很慢；对好消息反应很快，对坏消息反应可能很慢–&gt;无穷计数问题 一个不完全的解决方案：将路径长度无穷大设置为最长的路径+1 5.2.5 链路状态路由（link state routing）应用——OSPF 发现它的邻居节点，并了解其网络地址。（在每一个点到点线路中发一个Hello数据包） 设置到每个邻居节点的距离或者成本度量值。（常用方法是成本与链路带宽成反比，或者采用延迟时间当做成本，计算方法为来回时间/2） 构造一个包含所有刚刚获知的链路信息包。（数据包的内容：标识符（谁发出去的）、序号（泛洪要用）、年龄、&lt;邻居-延迟&gt;） 将这个包发送给所有其他的路由器，并接收来自所有其他路由器的信息包。（泛洪） 计算出到每个其他路由器的最短路径。（每个路由器以自己为根算一个最小生成树） 收敛性好、适用于大网络。但是计算略复杂 几个问题： 为了减少拓扑结构复杂性，LAN会被一个虚拟的节点代替，此时需要指定一个和这个LAN相连的路由器来代表这个虚拟节点向其他节点发送链路信息。算延迟的时候只算一边，如下图，A到N还是算延迟的，N到A的延迟可以认为是0. age字段每秒钟减1，减到0就丢弃数据包 图5-13 发送和确认 书上p291举的例子要理解 5.2.6 分层路由 书上图5-14 将路由器分成很多个子网络 同一个子网内的先跑一次算法，记录到节点的距离；然后连接不同子网的路由器之间再跑一次算法，一个节点到其他的子网不再记录到每一个节点的距离，只记录到子网的距离（数据包也只从同一个路由器走） 5.2.7 广播路由 Broadcast 方法： 多目标路由（multi-destination routing），在数据包中加入多个目标地址 泛洪 逆向路径转发（当路由器收到一个包，它判断来的那个端口是不是数据包从发送者开始沿最佳路径转发过来的端口。如果是，则将这个包转发到除了来的那个端口以外的所有端口；如果不是，丢弃数据包。） 生成树（每个路由器需要知道它的哪些端口在生成树上，然后将数据包发送到来源端口以外的在生成树上的端口。前提是路由器需要知道生成树，所以适用于链路状态路由算法，不适用于距离矢量路由算法） 5.2.8 组播路由 Multicast 最简单的方法是广播，但是会发到一些无关成员，造成浪费。 方法： 修剪树：图5-16，从根开始，从生成树上把不通往组成员的边删去。 缺点：路由器需要做大量的工作 具体的构造方法： 对于距离矢量算法，核心思想是逆向路径转发。如果一个路由器和这个组无关，需要发送一个PRUNE消息作为接受组播消息的相应，告诉邻居不要再给自己发送任何来自该组发送者的消息。——例子：距离矢量组播路由协议DVMRP（Distance vector multicast routing protocol） 对于链路状态路由算法，每个路由器知道生成树、拓扑结构、哪些主机输入哪个组，直接构造一棵sink tree，然后删除不连到组成员的链路即可。——例子：组播MOSPF（Multicast OSPF） 核心树（core-based trees），计算某个组的单棵生成树 采用这种方法时，所有路由器同意以某个路由器为根（称为核心core或者会聚点rendezvous point），然后每个成员给根发送一个数据包来构建树。 优点是每个路由器只要为每个组保存一棵树，省资源。例子——协议独立组播PIM（Protocol Independent Multicast） 5.2.9 选播路由 Anycast 所有被选到的成员将被赋予同一个组地址，然后路由器像往常一样工作，选择最短路径，所以数据包会被发送到距离路由器最近的一个组内节点。 5.2.10 移动主机路由 Mobile Host 图5-19 重要 4步：1.注册转交地址 2.发送者往家乡地址发送数据包 3. 隧道(tunneling)到转交地址（需要用一个新的头包裹，即封装该数据包，encapsulation） 4. 应答发送者 5. 发送者通过隧道将随后的数据包发给转交地址 5.2.11 自组织网络路由Ad hoc 图5-20（有点复杂） 5.3 拥塞控制算法（听说不考） 供给（provisioning），购买带宽或者网络资源 流量感知的路由（traffic-aware routing），把流量拆分到多个路径 只考虑负载时会带来不稳定的路由和许多潜在问题 准入控制（admission control）降低负载 漏桶：描述突发流量的描述符 ——5.4节讨论 一种方案：选择一条没有拥塞路由器的传输路径（和路由算法结合） 流量调节 两个问题： 如何确定快要发生拥塞？估计延迟时间，将上一次的延迟和当前瞬时队列长度的采样值进行加权平均，来估算排队延迟。 如何反馈信息给发送方？发送抑制包（choke packet）。方法是标记包头部的某一个bit。 Internet中的方案：显示拥塞通知（ECN，Explicit congestion notification）图5-25，当发送数据包时，如果经过了某个拥塞的路由器，就标记这个数据包，接受方看到标记以后可以在应答包当中顺便告知发送方拥塞的信息。 另一个方案：逐跳后压，书P309图5-26(b) 负载脱落（load shedding） 丢弃数据包：wine（旧的包比新的包重要，丢弃新的包）和milk（新的包比旧的包重要，丢弃旧的包） 随机早期检测算法（RED，Random early detection）当某条链路上的平均队列长度超过某个阈值时，随机丢弃一小部分数据包——在能使用ECN时优先用ECN 5.4 服务质量（听说不考） 5.4.1 背景：服务质量（QoS）=带宽+延迟+抖动（延迟的方差）+丢失 P312图5-27 重要 5.4.2 流量整形traffic shaping：客户向服务端描述可能的流量形式，这个约定有时又叫做服务等级约定（SLA，service level agreement）同时服务器要对一个流进行检测，丢弃超出约定模式之外的数据包，这个过程叫做流量监管（traffic policing） 漏桶和令牌桶： 漏桶算法leaky bucket algorithm 漏桶算法思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会直接溢出，可以看出漏桶算法能强行限制数据的传输速率。 令牌桶算法token bucket algorithm 令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。 见书P314倒数两段 P316有一个计算要掌握 5.4.3 数据包调度算法： FIFO 缺点是队列满了以后新来的包会被丢弃（尾丢包tail drop），有造成饿死的可能 公平队列算法（fair queueing）和加权公平队列算法（WFQ）书P318-319看书，理解掌握 5.4.4 ~ 5.4.6 Skipped 5.5 网络互联 5.5.1 要连接的网络可能有很多不同，见P327图5-38 5.5.2 路由器和交换机（网桥）的区别：路由器每次提取一个包的ip地址，然后根据不同网络采用不同的协议对数据进行封装。交换机（或网桥）上，整个帧是根据其MAC 地址传送的。交换机不必了解正在被交换的数据包所采用的网络层协议，同样路由器也不必了解交换机所采用的链路层协议。 5.5.3 隧道Tunneling 英吉利海峡那个例子，把原来的协议的数据包用隧道协议的包头封装 5.5.4 两级路由算法。在每个网络中，使用一个域内（ intradomain ）或者内部网关协议（ interior gateway protocol ）进行路由（“网关”是“路由器”的旧称）。为了让数据包跨越构成互联网的网络，就需要用到域间（ interdomain ）或外部网关协议（ exterior gateway protocol ）。网络可能全部使用不同的域内协议，但它们必须使用相同的域间协议。在Internet 上，域间路由协议称为边界网关协议（BGP, Border Gaterway Protocol ） 还有一个更重要的术语要介绍。由于每个网络独立于所有其他网络运营，因此这样的网络通常称为一个自治系统（ AS, Autonomous Sysem ）。AS 的良好默认模型是ISP 网络。事实上，一个ISP 网络或许由多个AS 组成，如果它管理或收购了多个网络。 5.5.5 分段 分段=拆+不拆，其中拆=透明+不透明，图5-42，注意不透明的时候包的重组是在目标主机完成的 路径MTU发现：图5-44 每个IP数据包发出时在它的头设置一个比特，指示不允许对该数据包实施分段操作。如果一个路由器接收的数据包太大，它就生成一个报错数据包并发送给源端，然后丢弃该数据包。 5.6 一、 IPv4 IP包的基本单位是字节，但是IP包头的基本单位是字 固定部分5个字+可选部分（0~10个字） IP地址 32bit 点分十进制表示法 子网掩码 子网划分 Version字段 0100 IHL字段 头的长度 最小值为5 因为只有4位 所以包头最大是15个字，即60字节，所以Options字段最多40字节 Differentiated Services 最开始叫Type of Service，6bit，但是后来弃用了，现在是8bit，前6 位用来标记数据包的服务类别，我们在本章前面描述过的加速服务和确保服务：后2位用来携带显式拥塞通知信息，比如数据包是否经历了拥塞，我们在本章的拥塞控制部分描述了显式拥塞通知。 Total Length 数据包（头+数据）总长度，16bit，说明数据包最多65535字节（常考） Identification 和源地址、目标地址一起，三者唯一确定一个数据包 Time to live 原来是这个包在网络上存在的时间，以秒为单位。现在是跳计数器，当它递减到0 时，数据包就被丢弃，并且路由器给数据包的源主机发回一个报警包。 Protocol 后面的数据的协议 Header Checksum 包头部的校验和 算法：当数据到达时，所有的16位（半宇）累加起来，然后再取结果的补码。该算法的目的是到达数据包的头校验和计算结果应该为0。 DF=don’t fragment 置1表示不允许分段 MF=more fragments 置1表示不是最后一个段 Fragment offset 指明了该段在当前数据报中的位置。除了数据报的最后一个段以外，其他所有段的长度必须是8字节的倍数。由于该字段有13位，所以每个数据报最多有8192个段 从概念上讲， CIDR 的工作原理如下所述。当一个数据包到达时，路由器扫描路由表以便确定目的地是否在前缀的地址块内。有可能多个具有不同前缀的表项得到匹配，在这种情况下，使用具有最长前缀的表项。因此，如果有一个匹配/20掩码的表项，同时还有一个匹配/24掩码的表项，则使用/24表项来查询数据包的出境线路。——最长前缀匹配策略 分类寻址 图5-53 5种类型 特殊寻址 图5-54 考试——例：C类地址最多有多少个主机：2^8 -2=254（去掉全0全1） A类地址开头的Network是1-127 不是0-127 B类和C类 network可以填0 NAT 1.出境时做地址的映射，同时进程将自己绑定到一个“源端口“上 2.入境时，需要维护一个&lt;IP+端口&gt;→&lt;路由器端口&gt;的表 二、IPv6 还是32bit的整数倍 区分服务字段：和IPv4相同，8bit Flow label：流的标识符 用于服务品质 有效载荷长度（Payload Iength）宇段指明了紧跟在图5-56 中40 个字节头之后还有多少字节数。和IPv4不同，40 字节的头不再像以前那样算作长度中的一部分。 Next header字段 表明当前头之后还有哪些头 最后一个头的该字段表示该数据包将被传递给哪一个传输协议处理 跳数限制Hop limit相当于IPv4里的TTL IP地址：16个字节 冒号十六进制记法 扩展头——逐跳头hop-by-hop header 书p355 图5-58 要熟悉 三、IP控制协议 ICMP——Internet控制消息协议 P358图5-60 底层是IP协议来承载 ARP——地址解析协议 核心是要获取目标的以太网地址 P360图5-61 一台机器用了ARP之后可以将结果缓存起来。ARP缓存项应当有一个过期时限。 一台机器重新配置IP之后应当发送一个ARP请求广播自己的IP地址，会在其他主机的ARP缓存中加入一个表项。这个请求成为免费ARP（gratuitous ARP）。如果发送这个ARP包的主机意外收到了一个应答，说明两台机器被分配了相同的IP地址。 默认网关：一台主机想要给网络外的主机发送信息时，查找的默认的路由器 ARP代理：路由器代替网络外的主机回复ARP请求报文（P361有个例子） DHCP——动态主机配置协议 每个网络需要有一个DHCP服务器负责地址配置。主机启动的时候会广播一个报文请求IP地址，这个包叫做DHCP DISCOVER包。DHCP服务器收到以后分配一个IP地址，发送DHCP OFFER包返回。 一般采用租赁（leasing）技术，分配的IP地址要定期renew MPLS——多协议标签交换 首先回忆标签交换：根据一个标签label进行发送路径的判断，本质是交换而不是转发，见图5-3 MPLS中，主机和进入MPLS网络的第一个路由器（称为标签边缘路由器，LER，Lable Edge Router）之间采用无连接的IP协议，在MPLS网络内部采用面向连接的技术。MPLS中的路由器被叫做标签交换路由器（LSR，Label Switched Router）。完整过程见P364 图5-63 MPLS是一个2.5层的协议。标签会放在一个帧的头部，帧格式见图5-62，4bit，标签20bit，存放了索引。 对路由器来说，更常见的做法是将终止在某个特定路由器或者LAN 的多个流合并成一组，并为这些流使用同一个标签。这些被合起来共享同一个标签的流称为属于同一个转发等价类（FEC, Forwarding Equivalence Class） 实际应用中一个包可能有多个标签，称为标签栈。图5-62中的S bit为1时表示这个标签是最底部的标签，下面没有其他标签了。QoS表示服务的类别。TTL字段指出该数据包还能被转发多少次，每经过一个路由器被递减1 。如果降为0，则该数据包将被丢弃。 RIP——Routing Information Protocol 距离向量算法 收敛性不好 只能用于小网络 两个路由器之间的距离默认为1 内部路由协议IGP 用UDP承载 RIP 1版本仅支持分类的IP地址，不支持无级的IP地址，RIP2都支持 OSPF——内部网关路由协议 链路状态算法 骨干网 内部路由协议IGP 用IP承载 区域边界路由器（ABR）、骨干路由器、AS边界路由器（ASBR）、内部路由器的理解 P367图5-65 外部成本指从AS 边界路由器通往目的地的外部路径的成本。 部分细节 skipped BGP——外部网关路由协议 距离向量算法（变种）但是不仅互相传输到目的地的距离，还传输到目的地的路径 所以改善了收敛性 外部路由协议EGP 用TCP承载 6 运输层 TCP状态机 要考填空 数据链路层 点对点 包接受的顺序和发送的顺序一样 没有存储能力 运输层 端对端 要解决顺序问题 且路由器有存储能力 要解决包隐藏的问题 如何唯一标识一个连接：通过两个端点在空间上标识一个连接；通过序号（可循环使用）区分时间上前后的连接，这个序号选一个最近合理的时间范围内没有使用过的即可 连接建立：三次握手=连接请求+连接请求确认+连接请求确认的确认 6.4 UDP 用户数据报协议 无连接 实时性好 可靠性不好 包的格式：整数个字节 由头部+payload组成 头部以字为单位（4字节的整数倍） （不一定基于IP协议） 加了源端口（16bit）和目标端口（16bit） 从而支持多个任务 因为端口16bit 所以一共0-65535 共65536个端口 拿IP协议的假头一起来算checksum RPC（Remote Procedure Call）远程过程调用 RTP（Real-time Transport Protocol）实时传输协议 要支持多个流 保证流之间的顺序 并保证流之间的同步 由头部+payload组成 头部以字为单位（4字节的整数倍） 时间戳：用于同步 CC表示有多少个流被合并了 然后通过identifier分离 RTP的伴随协议RTCP 两者都是用UDP承载的 RTCP表示当前网络承载的情况 6.5 TCP 面向连接 实时性不好 可靠性好 面向字节流","link":"/2020/12/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"其它","slug":"其它","link":"/tags/%E5%85%B6%E5%AE%83/"},{"name":"Courses","slug":"Courses","link":"/tags/Courses/"}],"categories":[]}